import{_ as n,l as t,m as s,n as _,B as e,G as o,Q as i,s as l,J as a}from"./chunks/framework.4100087b.js";const S=JSON.parse('{"title":"正则匹配","description":"","frontmatter":{},"headers":[],"relativePath":"zh-CN/regexp.md","filePath":"zh-CN/regexp.md"}'),r={name:"zh-CN/regexp.md"},h=i('<h1 id="正则匹配" tabindex="-1">正则匹配 <a class="header-anchor" href="#正则匹配" aria-label="Permalink to &quot;正则匹配&quot;">​</a></h1><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>正则匹配功能的最低使用权限为 3 级。你可以通过配置 <a href="./config.html#authority">authority.regExp</a> 修改这个行为。</p></div><h2 id="基本用法" tabindex="-1">基本用法 <a class="header-anchor" href="#基本用法" aria-label="Permalink to &quot;基本用法&quot;">​</a></h2><p>如果你希望匹配问题中的某些特征而不是问题整体，你可以使用 <code>-x</code> 进行正则表达式匹配。下面是一个例子：</p>',4),p=i('<p>在这个例子中，<code>^</code> 和 <code>$</code> 分别匹配问答的起始和结尾，<code>.+</code> 匹配若干个非换行字符，<code>$1</code> 表示第一个括号内的文本。这样的语法极大地提升了问答捕获的自由度。</p><p>对于已有的问答，我们也可以使用 <code>-X</code> 来取消使用正则表达式匹配。</p><p>此外，我们约定在实际触发时，如果一个问题同时能够触发正则匹配和非正则匹配的回答，会优先触发非正则匹配的问答。因此不必担心正则匹配的教学会影响已有问答的触发效果。</p><h2 id="支持的语法" tabindex="-1">支持的语法 <a class="header-anchor" href="#支持的语法" aria-label="Permalink to &quot;支持的语法&quot;">​</a></h2><p>下面是教学功能所支持的正则表达式语法：</p><ul><li><code>\\</code>：对后面的字符进行转义</li><li><code>.</code>：匹配除换行以外的任意字符</li><li><code>^</code>, <code>$</code>：匹配开头 / 结尾位置</li><li><code>[abx-z]</code>, <code>[^abx-z]</code>：匹配正值 / 负值字符集合</li><li><code>*</code>：匹配前面的子式任意次</li><li><code>+</code>：匹配前面的子式至少 1 次</li><li><code>?</code>：匹配前面的子式 0 次或 1 次</li><li><code>{n}</code>：匹配前面的子式 n 次</li><li><code>{m,n}</code>：匹配前面的子式至少 m 最多 n 次</li><li><code>x|y</code>：匹配 x 或 y</li><li><code>(patt)</code>：匹配 patt 并捕获</li></ul><div class="danger custom-block"><p class="custom-block-title">警告</p><p>MySQL 5.7 使用的正则表达式规范是 POSIX 1003.2，这是一个很落后的版本。下面的语法都是<strong>不被支持</strong>的：</p><ul><li><code>\\d</code>, <code>\\D</code>：转义字符集</li><li><code>\\b</code>, <code>\\B</code>：单词边界</li><li><code>+?</code>, <code>*?</code>：非贪婪匹配</li><li><code>(?:</code>, <code>(?=</code>：非捕获组</li></ul><p>因此我们建议你使用 mariadb 10.5 以上的版本以取代 MySQL。</p></div><h2 id="正则表达式与称呼匹配问答" tabindex="-1">正则表达式与称呼匹配问答 <a class="header-anchor" href="#正则表达式与称呼匹配问答" aria-label="Permalink to &quot;正则表达式与称呼匹配问答&quot;">​</a></h2><p>TODO</p><h2 id="搜索中的正则匹配" tabindex="-1">搜索中的正则匹配 <a class="header-anchor" href="#搜索中的正则匹配" aria-label="Permalink to &quot;搜索中的正则匹配&quot;">​</a></h2><p>默认情况下，使用搜索功能的效果与实际触发时类似。换言之，当你使用问答搜索时，无论正则匹配还是非正则匹配到的问答都会被显示。但在一些情况下，我们可能会有其他不同的需求。</p><p>最常见的情况就是我们希望用正则表达式来搜索问答原文（这听起来与普通的搜索有点类似，但实际上这里的匹配关系是相反的）。对于这种情况，只需在搜索时附带一个 <code>-x</code> 即可。而此时的搜索结果也会显示完整的问题和回答（如果不使用正则匹配，由于你已经提供了完整的问题或回答，则不会重复显示）：</p>',12),u=l("p",null,"问题正则表达式“一时”的搜索结果如下：",-1),m=l("p",null,"1001. 正则：^(.+)一时爽$，回答：一直$1一直爽",-1),f=l("p",null,[a("另一种情况则是我们希望只显示那些非正则匹配到的结果。此时只需在搜索时附带一个 "),l("code",null,"-X"),a(" 即可。我们来对比一下搜索结果：")],-1),x=l("br",null,null,-1);function k(b,T,g,A,N,P){const c=t("chat-message"),d=t("chat-panel");return s(),_("div",null,[h,e(d,null,{default:o(()=>[e(c,{nickname:"Alice"},{default:o(()=>[a("# ^(.+)一时爽$ 一直$1一直爽 -x")]),_:1}),e(c,{nickname:"Koishi"},{default:o(()=>[a("问答已添加，编号为 1001。")]),_:1}),e(c,{nickname:"Alice"},{default:o(()=>[a("挖坑一时爽")]),_:1}),e(c,{nickname:"Koishi"},{default:o(()=>[a("一直挖坑一直爽")]),_:1})]),_:1}),p,e(d,null,{default:o(()=>[e(c,{nickname:"Alice"},{default:o(()=>[a("## 一时 -x")]),_:1}),e(c,{nickname:"Koishi"},{default:o(()=>[u,m]),_:1})]),_:1}),f,e(d,null,{default:o(()=>[e(c,{nickname:"Alice"},{default:o(()=>[a("## 挖坑一时爽")]),_:1}),e(c,{nickname:"Koishi"},{default:o(()=>[a("问题“挖坑一时爽”的回答如下："),x,a("1001. [正则] 一直$1一直爽")]),_:1}),e(c,{nickname:"Alice"},{default:o(()=>[a("## 挖坑一时爽 -X")]),_:1}),e(c,{nickname:"Koishi"},{default:o(()=>[a("没有搜索到问题“挖坑一时爽”。")]),_:1})]),_:1})])}const q=n(r,[["render",k]]);export{S as __pageData,q as default};
